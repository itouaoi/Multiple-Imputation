![Multiple Imputation with mice](https://user-images.githubusercontent.com/82706937/173745586-c4f51293-a6ff-43be-abee-cd44dd892a2d.png)

`mice`パッケージを用いて欠損値の多重代入法を実行する方法をまとめました。ここでは、はじめに**基本編として「シングルレベルの多重代入法」**、つぎに**応用編として「マルチレベルの多重代入法」** について説明しています。なお、マルチレベルの多重代入法は、何らかの階層を持つデータにおける欠損値の多重代入法であり、シングルレベルの多重代入法とは異なるプログラムを組む必要があります。

## コード一覧   
ここで示すコードは、それぞれ以下のファイルにあります。  
+ mi_cross: 基本編「シングルレベルの多重代入法」
+ mi_long : 応用編「マルチレベルの多重代入法」

## パッケージのインストールと読み込み  
```r
install.packages("mice"); install.packages("broom.mixed")
library(mice); library(broom.mixed)
```

## miceによる多重代入の最も基本的な流れ
`mice`パッケージを使えば、欠損値に対する多重代入法を以下のような数行のコードで実行することができます。  
しかし、データに含まれる変数の種類や分布の形によって適切な多重代入の方法が異なるため、**使用するデータに合わせてカスタマイズする必要があります。**  

```r
#Basic workflow with mice
imp <- mice(nhanes)             #Imputation
fit <- with(imp, lm(chl ~ bmi + age)) #Analysis
res <- pool(fit)                #Pooling
summary(res)
```

***

# 基本編「シングルレベルの多重代入法」

## 準備：データの要約と分布の確認
`mice`パッケージ内に含まれている`nhanes2`のデータを用いて演習します。  
`nhanes2`のデータを取り込んだら、まずデータの要約や分布を確認してみましょう。
```r
#1.Check the data distributions and pattern　　
data <- nhanes2; attach(data); summary(data)
par(mfrow = c(2,2)); hist(bmi); hist(chl); plot(age); plot(hyp)
```    

`nhanes2`には、25名の年齢（age）、体重（bmi）、高血圧の有無（hyp）、コレステロール値（chl）の4つの変数が含まれています。それぞれのデータの型は、ageは３つのカテゴリー変数、hypは２値のカテゴリー変数、bmiとchlは連続変数です。
```r
#>    age          bmi          hyp          chl       
#> 20-39:12   Min.   :20.40   no  :13   Min.   :113.0  
#> 40-59: 7   1st Qu.:22.65   yes : 4   1st Qu.:185.0  
#> 60-99: 6   Median :26.75   NA's: 8   Median :187.0  
#>            Mean   :26.56             Mean   :191.4  
#>            3rd Qu.:28.93             3rd Qu.:212.0  
#>            Max.   :35.30             Max.   :284.0  
#>            NA's   :9                 NA's   :10     
```

次に、それぞれのデータの分布を確認します。

![image](https://user-images.githubusercontent.com/82706937/173509244-0078e293-da4c-4023-968f-49ce60316fed.png)  
それぞれ、データの分布は異なりますが、`mice`では、連続変数、カテゴリー変数など様々な種類の変数に対する代入が可能です。

## 準備：欠測パターンの確認
次に重要なのは、**それぞれの変数に欠損値がどのように発生しているか**（欠測パターン）を確認することです。これには、`md.pattern`関数を使用します。  
```r
md.pattern(data)
```
![image](https://user-images.githubusercontent.com/82706937/173512297-39e5d84b-e133-49a5-8aa1-782f0cfb15a5.png)  
この図では、データセットにおける欠損値の発生状況を示しており、青は「データあり」、赤は「欠測」です。  
+ **初めの列は、各欠測パターンの頻度を示します。**  
例えば、上の２つをみてみると、全てのデータがある者は13名、chlだけが欠測している者は3名であることがわかります。
+ **最後の列は、各欠測パターンにおける欠測値の数を示します。**  
例えば、一番上の行は全てが青（データあり）なので、欠損値の数は０。二番目の行は、4つの変数のうちchlだけ赤（欠損）なので１です。
+ **最後の行は、各変数の欠損値の数を示します**  
例えば、各変数における欠損値は、ageには0個、hypには8個、bmiには9個、chlには10個、それぞれあることがわかります。なお、変数は左から欠損値の少ない順に並べられています。

![POINT](https://user-images.githubusercontent.com/82706937/173568537-dced2a6b-d924-4e41-827b-1c26743adc97.png)  
**欠測値を代入する前に、「データの要約と分布」と「欠損値の発生パターン」を確認する**  
***

## 代入ステップ
`mice`パッケージを用いた多重代入は、`mice()`による**代入**、`with()`による**分析**、`pool()`による分析結果の**統合**の３ステップに分けられます。まず、最初のステップである代入から説明します。

`mice()`を使った代入は、以下のコードで実行できます。
```r
#2-1.Imputation with default setting (m=5)
imp1 <- mice(data = data, seed = 1234)
```  
`mice()`のdataには、代入を行いたいデータセットを指定し、seed（シード値）は、再現性のある結果を得るために必要です。なお、ここではまだ必要最低限の引数しか指定していませんが、`mice()`はデフォルトの設定を自動的に適用し、代入を実行します。  

## 図による代入結果の確認  
上記のコードを使って代入ができたら、**代入の結果をプロットして確認しましょう**。代表的なプロットとしては、**収束プロット、密度プロット、散布図**があります。それぞれの図の見方を簡単に説明します。
```r
#2-2.Plot 
plot(imp1)
densityplot(imp1)
stripplot(imp1, pch = 19, xlab = "Imputation number")
```
### １．収束プロット（平均値と標準偏差）  
![image](https://user-images.githubusercontent.com/82706937/173517190-91495a46-e7c5-490a-ad9a-293d55b10b00.png)  
`plot()`で作られるこの図は、横軸をインタラクションの回数として、縦軸に代入した値の平均値や標準偏差などのパラメターをプロットしたものです。それぞれ5本の線があるのは、代入を5回しているためです。この図を見て、**各曲線間におけるばらつきが、個々の曲線内におけるばらつきよりも大きくなっていない場合に、収束していると診断します** (Van Buuren, S. 2018)。 それぞれの変数における曲線の流れを読み取ることで、代入の問題点を見つけることができます。  

### ２．密度プロット（Density Plot） 
![image](https://user-images.githubusercontent.com/82706937/173520401-92dd3a7d-16c2-461e-937d-5c5b3f0c2f6c.png)  
`densityplot()`でつくられるこの図は、観測データと代入済みデータの密度をそれぞれ示したものです。青い線は観測データ、赤い線は代入済みデータをそれぞれ示しています。この図において青と赤の線の分布が大きく異なる場合は注意が必要です。その場合は、代入モデルが適切ではなかったり、そもそもの欠損データのメカニズムがMCAR（完全に無作為な欠測）でない可能性が考えられます。  

例えば、上記の図例からは、観測データと代入済みデータの密度が、chlよりもbmiで大きくずれていることがわかります。  

### ３．ストリッププロット（Strip Plot） 
![image](https://user-images.githubusercontent.com/82706937/173524212-ad1872fa-fd72-4204-affb-fef3fdee9004.png)  
`stripplot()`で作られるこの図は、**横軸を代入の回数(m)、縦軸を各変数の観測値と代入された値**とした図です。青い点は観測データ、赤い点は代入済みデータをそれぞれ示しています。

***

## 分析ステップ
欠損値の代入ができたら、次は`with()`を使って分析を行います。分析ステップでは、ｍ組の疑似的な完全データを標準的な統計手法を用いてｍ回解析し、パラメータ推定値とその分散を得ます（阿部, 2016, p96）。用いることのできる統計手法は様々ですが、ここでは回帰分析を用いて分析していきます。  
```r
#3. Analysis
fit1 <- with(imp1, lm(chl ~ bmi + age)) 
```

## 統合ステップ
分析ステップの次は、`pool()`を使ってすべての結果を**統合**します。  estimateはｍ回の代入による推定値、ubar、b、tは分散の推定量、df comは仮説的な完全データの自由度、dfはRubinの
`summary()`を使って、最終的な解析結果の要約を確認することができます。

```r
#Pooling the results
res1 <- pool(fit1)
res1
summary(res1)
```

res1の中に、統合された結果を格納しました。中身を確認してみると以下のようになります。
```r
res1
#> Class: mipo    m = 5 
#>          term m  estimate        ubar           b           t dfcom        df       riv    lambda       fmi
#> 1 (Intercept) 5 10.663179 3019.802215 727.1210629 3892.347491    21 12.575300 0.2889412 0.2241694 0.3237926
#> 2         bmi 5  5.617963    3.658844   0.7508079    4.559813    21 13.422759 0.2462443 0.1975891 0.2953085
#> 3    age40-59 5 48.705149  249.114148  98.2435756  367.006438    21  9.772408 0.4732461 0.3212268 0.4275142
#> 4    age60-99 5 65.834508  288.402561 351.8903635  710.670997    21  4.623812 1.4641633 0.5941827 0.7006432

summary(res1)
#>          term  estimate std.error statistic        df    p.value
#> 1 (Intercept) 10.663179 62.388681 0.1709153 12.575300 0.86700972
#> 2         bmi  5.617963  2.135372 2.6309059 13.422759 0.02030861
#> 3    age40-59 48.705149 19.157412 2.5423658  9.772408 0.02973143
#> 4    age60-99 65.834508 26.658413 2.4695584  4.623812 0.06056866
```
上記の結果を一度に表示したい場合は、以下のコードを用います。
```r
summary(res1, "all", conf.int = TRUE)
```
# 発展：基礎編「シングルレベルの多重代入法」をカスタマイズ
ここまでは、多重代入の準備→実行→評価の大きな３つの作業の流れを述べました。しかし、実際の研究では、今回の例で使ったような小さなデータセットではなく、より大きく多種多様な変数を含むデータセットを扱うことになると思います。よって、ここからはより大きく、複雑なデータセットの欠損値に対する多重代入法について説明します。

### mice()の使い方の詳細
mice()は、代入を実行する関数ですが、引数に渡す値を操作することでフレキシブルな代入を行うことができます。様々な引数がありますが、特に重要な引数として、**data（代入したいデータセットの指定）、predictorMatrixまたはpred（代入に用いる予測変数の指定）、method（代入に用いる方法の指定）、m（代入回数の指定）、maxit（インタラクションの回数の指定）** があります。

```r
#Usage of mice (ver 3.14.0)
mice(
  data,
  m = 5,
  method = NULL,
  predictorMatrix,
  ignore = NULL,
  where = NULL,
  blocks,
  visitSequence = NULL,
  formulas,
  blots = NULL,
  post = NULL,
  defaultMethod = c("pmm", "logreg", "polyreg", "polr"),
  maxit = 5,
  printFlag = TRUE,
  seed = NA,
  data.init = NULL,
  ...
)
```
### とくに重要な引数
#### method: 各変数の代入方法の指定
`mice()`の引数であるmethodは、各変数に対する代入方法を指定します。指定できる代表的な方法には、**pmm、norm、logreg、polyreg**などがあります。 もしも、この引数をとくに操作しなければ、`mice()`は、自動的に各変数に対して適切な方法を指定します。しかし、その方法が必ずしも最適な方法かはわからないため注意が必要です。


#### pred: 各変数の代入に用いる変数の指定
`mice()`の引数であるpredは、各変数を代入する際に代入値の予測変数として用いる変数を指定する、0と1からなる行列です。もしも、この引数にとくに操作しなければ`mice()`は、自動的にその変数以外のすべての変数を予測変数として使用します。

#### maxit: インタラクションの回数
代入ごとのインタラクションの回数。5~20回  

#### m: 代入の回数  
代入する回数の指定。デフォルトは5回。  

# 応用編
作成中

# 補足
エラー対処法について



<b>参考文献</b> <br>
Van Buuren, S. (2018) Flexible Imputation of Missing Data.
